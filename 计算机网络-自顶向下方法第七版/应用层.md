# 应用层

研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。

两种主流应用程序体系结构 (application architecture)：客户-服务器体系结构或对等（P2P）体系结构。

客户-服务器体系结构（client-server architecture））中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。

 P2P 体系结构 P2P architecture） 中，对位于数据中心的专用服务器有最小的（或者没有）依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方。


### 进程通信

进程与计算机网络之间的接口：进程通过一个称为**套接字（socket）**的软件接口向网络发送报文和从网络接收报文。套接字是同一台主机内**应用层与运输层之间的接口**。
由于套接字是建立网络应用程序的可编程接口，因此也称之为应用程序和网络之间的应用程序编程接口（Application Programming Interface, API）。

应用开发者对运输层的控制仅限于：①选择运输层协议；②也许能设定几个运输层参数，如最大缓存和最大报文段长度等。

![](/计算机网络-自顶向下方法第七版/image/应用进程、套接字和下面的运输层协议.png)

进程寻址
一台主机上的进程向另外一台主机上的进程发送分组，接收进程需要一个地址，为了标识该接收的进程，需要定义两种信息：
IP地址(IP address)用于识别主机（IPV4 IPV6
端口号(port number)用于识别套接字


### 传输协议的选择：
运输协议服务：可靠数据传输、吞吐量（发送进程能够向接收进程交付比特的速率）、定时（延迟100ms以内最佳）和安全性

#### TCP
TCP服务模型包括**面向连接服务**和**可靠数据传输服务**。

面向连接服务：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。在握手阶段后，一个***TCP连接***（TCP connection）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，拆除该连接。

可靠的数据传送服务：通信进程能够依靠TCP,无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。

当发送方和接收方之间的网络出现拥塞时，TCP的**拥塞控制机制**会抑制发送进程（客户或服务器），也会试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。

安全：安全套接字层（Secure Sockets Layer, SSL） 用SSL加强后的TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。我们强调SSL不是与TCP和UDP在相同层次上的第三种因特网运输协议，而是一种对TCP的加强，这种强化是在应用层上实现的。特别是，如果一个应用程序要使用SSL的服务，它需要在该应用程序的客户端和服务器端包括SSL代码（利用现有的、高度优化的库和类）。SSL有它自己的套接字API,这类似于传统的TCP套接字API。当一个应用使用SSL时，发送进程向SSL套接字传递明文数据；在发送主机中的SSL则加密该数据并将加密的数据传递给TCP套接字。加密的数据经因特网传送到接收进程中的TCP套接字。该接收套接字将加密数据传递给SSL,由其进行解密。最后，SSL通过它的SSL套接字将明文数据传递给接收进程。

#### UDP
**仅提供最小服务**：不保证该报文将到达接收进程，且不保证到达数据的顺序。


#### 应用层协议（application-layer protocol）
定义运行在不同的端系统的进程如何相互传递报文
1、交互的报文的类型。（请求和响应报文）
2、文本类型的语法，如报文中的字段以及这些字段是怎么描述的
3、字段的语义，即字段中信息的含义
4、一个进程何时以及如何发送报文，对报文进行响应的规则。

#### Web
web的应用层协议是超文本传输协议（HyperTest Transfer Protocol, HTTP），是web的核心。

http协议由两个程序实现：一个客户程序和服务器程序。因为HTTP服务器并不保存关于客户的任何信息，所以
我们说HTTP是一个无状态协议(stateless protocol)。
关于HTTP协议可以浏览相关书籍。

关于连接的非持续连接(non-persistent connection)与持续连接(persistent connection)。

##### http：
一个典型的HTTP请求报文：
```
GET /somedir/page html HTTP/1.1           
Host: www.someschool.edu                  
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
// 第一行叫作请求行（request line）
// 后继的行都叫做作首部行 header line）
```
特点：
ASCII文本书写、每行由一个回车和换行符结束。

请求行有3个字段：
- 方法字段：
    - GET
    - POST
    - HEAD（只是看HTTP协议的报文行，而不是获取对象本身，可用于检索目标是否存在于服务器
    - PUT和DELETE
- URL字段：
- HTTP版本字段：

首部行：
- Host：该首部行提供的信息是Web代理高速缓存所要求的
- Connection：close，表明浏览器告诉服务器不要麻烦地使用持续连接
- User-agent：用来指明用户代理，即向服务器发送请求的浏览器的类型。
- Accept-language：语言版本，可以根据此首部行发放不一样的数据

![](/计算机网络-自顶向下方法第七版/image/—个HTTP请求报文的通用格式.png)

一个典型的HTTP响应报文：
```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tuer 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(data data data data data •••)
// 有三个部分：一个初始状态行（status line）, 6个首部行 headerline）,
// 然后是实体体（entity body）
```

状态行有3个字段：
- 协议版本字段
- 状态码
    - 200 0K 请求成功，信息在返回的响应报文中。
    - 301 Moved Permanently 请求的对象已经被永久转移了，新的URL定义在响应报
    文的Location:首部行中。客户软件将自动获取新的URL
    - 400 Bad Request: 一个通用差错代码，指示该请求不能被服务器理解。
    - 404 Not Found:被请求的文档不在服务器上。
    - 505 HTTP Version Not Supported:服务器不支持请求报文使用的HTTP协议版本。

- 相应状态信息

首部行：
- Date：首部行指示服务器产生并发送该响应报文的日期和时间，是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间
- Server：首部行指示该报文是由一台Apache Web服务器产生的，类似于HTTP请求报文中的User-agent:首部行。
- Last-Modified：首部行指示了对象创建或者最后修改的日期和时间。此行对既可能在本地客户也可能在网络缓存服务器（代理服务器）上的对象缓存来说非常重要
- Content-Length：首部行指示了被发送对象中的字节数
- Content-Type：首部行指示了实体体中的对象是HTML文本


#### 用户和服务器的交互：cookie
由于HTTP服务器是无状态的，然而一个Web站点通常希望能够识别用户，将内容与用户身份联系起来，因此使用了cookie。cookie允许站点对用户进行跟踪。

cookie技术有4个组件：
1. 在http的响应报文中的一个cookie首部行
2. 在http请求报文中的一个cookie首部行
3. 在用户端系统中保留一个cookie文件，可通过用户的浏览器进行管理
4. 位于web站点的一个后端数据库

cookie的工作过程：


用户通过浏览器访问服务器，当请求报文到达该服务器时，该Web站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生一个表项。接下来服务器用一个包含Set-cookie首部的HTTP响应报文对用户的浏览器进行响应，其中Set-cookie 首部含有该**识别码**。例如，该首部行可能是
```
Set-cookie: 1678
```
当用户的浏览器收到了该HTTP响应报文时，它会看到该Set-cookie这个首部。浏览器会在它管理的特定cookie文件中添加一行。该行包含服务器的主机名和在Set-cookie:首部中的识别码。
当用户再次访问该服务器时，每次请求一个web页面，浏览器会查询cookie文件，并且抽取之前设置的**识别码**，并且放入到请求报文的cookie首部行中。
```
cookie: 1678
```
因此，cookie可以用于标识一个用户。（谷歌的计划使用FLoC技术代替第三方cookie


#### Web缓存
Web缓存器（ Web cache）也叫代理服务器（proxy server），能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间,并在存储空间中保存最近请求过的对象的副本。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web缓存器。
 
1. 浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。
2. Web缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。
3. 如果Web缓存器中没有该对象，它就打开一个与该对象的初始服务器的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求。在收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应。
4. 当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本（通过现有的客户浏览器和Web缓存器之间的TCP连接）。值得注意的是Web缓存器既是服务器又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户。

因特网上部署Web缓存器的优点：
1. Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。如果在客户与Web缓存器之间有一个高速连接（情况常常如此），并且如果用户所请求的对象在Web缓存器上，则Web缓存器可以迅速将该对象交付给用户。
2. Web缓存器能够大大减少一个机构的接入量 链路到因特网的通信量。通过减少通信量，该机构（如一家公司或者一所大学）就不必急于增加带宽，因此降低了费用。

通过使用**内容分发网络（Content Distribution Network, CDN）** , Web缓存器正在因特网中发挥着越来越重要的作用。CDN公司在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化。有多个共享的CDN （例如Akamai和Limelight）和专用的CDN（例如谷歌和Netflix）


#### DNS：因特网的目录服务
人们喜欢便于记忆的主机名标识方式，而路由器则喜欢定长的、有着层次结构的IP地址。
因此需要一种使主机名到IP地址转换的目录服务，也就是域名系统（Domain Name System, DNS）。

DNS是：①一个由分层的DNS服务器（DNS server）实现的分布式数据库；②一个使得主机能够查询分布式数据库的应用层协议。

根DNS服务器 -> 顶级域(DNS)服务器(Top level Domain) -> 权威DNS服务器

DNS通常被其他应用层协议所使用，HTTP，SMTP，FTP。

DNS别的业务：
 - 主机别名（host aliasing）：有着复杂主机名的主机能拥有一个或者多个别名。应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址。
的IP地址
 - 邮件服务器别名（mail server aliasing）：电子邮件应用程序可以调用DNS,对提供的主机名别名进行解析，以获得该主机的规范主机名及其IP地址。
 - 负载分配（load distribution）：DNS也用于在冗余的服务器（如冗余的Web服务器等）之间进行负载分配。繁忙的站点（如cnn. com）被冗余分布在多台服务器上,每台服务器均运行在不同的端系统上，每个都有着不同的IP地址。由于这些冗余的Web服务器，一个IP地址集合因此与同一个规范主机名相联系。DNS数据库中存储着这些IP地址集合。当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常总是向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载。

DNS工作机理：
有3种类型的DNS服务器：
 1. 根DNS服务器：
    由13个不同的组织管理400多个根名字服务器
 2. 顶级域(Top Level Domain, TLD) DNS服务器：对于每个顶级域(如com、org、net、edu和gov)和所有国家的顶级域(如uk、fr、ca和jp),都有TLD服务器(或服务器集群)。
 3. 权威DNS服务器：在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。

为了理解这3种类型的DNS服务器交互的方式，假定一个DNS客户要决定主机名www.amazon.com的IP地址。粗略说来，将发生下列事件。客户首先与根服务器之一联系，它将返回顶级域名com的TLD服务器的IP地址。该客户则与这些TLD服务器之一联系，它将为amazon.com返回权威服务器的IP地址。最后该客户与amazon.com权威服务器之一联系，它为主机名www.amazon.com返回其IP地址。
![](/计算机网络-自顶向下方法第七版/image/各种DNS服务器的交互.png)

严格说来，本地DNS服务器（local DNS server）并不属于该服务器的层次结构，但它对DNS层次结构至关重要。每个ISP（如一个居民区的1SP或一个机构的ISP）都有一台本地DNS服务器（也叫默认名字服务器）。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址（通常通过DHCP）。通过访问Windows或UNIX的网络状态窗口，用户能够容易地确定他的本地DNS服务器的IP地址。主机的本地DNS服务器通常“邻近”本主机。对某机构ISP而言，本地DNS服务器可能就与主机在同一个局域网中；对于某居民区ISP来说，本地DNS服务器通常与主机相隔不超过几台路由器。当主机发岀DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中。


###  P2P文件分发
P2P应用
Web、电子邮件、DNS都是采用客户－服务器体系结构，极大地依赖总是打开的基础设施服务器。

而实用P2P体系结构，对总是打开的基础设施服务器有最小（或者没有）依赖。
成对的间歇链接的主机（称为对等方）彼此直接通信。这些对等方不为服务商所拥有，而是受用户控制的桌面计算机或笔记本电脑。

P2P文件分发中，每个对等方能够重新分发它所拥有的该文件的任何部分，从而在分发过程中协助该服务器。
分发时间：N个对等方得到该文件副本所需要的时间，P2P分发时间取决于每个对等方如何向其他对等方分发该文件的各部分。

BitTorrent(一种用于文件分发的流行P2P协议):
术语：参与一个特定文件分发的所有对等方的集合被称为一个洪流（torrent）。每个洪流具有一个基础设置，称为追踪器（tracker）一个对等方加入到某个洪流的时候，它会向追踪器注册自己，且会周期性的通知追踪器它仍然存在于该洪流中。
洪流中的对等方彼此的下载等长度的文件块（chunk），典型的块长长度为256KB。随着时间的流逝，对等方积累越来越多的块，当它下载块的同时，同时也为其他的对等方上载了多个块，下载完整文件副本后，可离开洪流。
最稀缺优先（rarest first）技术：（对等方针对没有的块，在邻近的对等方中（邻居中副本数量最稀缺的块），并且会首先请求那些最稀缺的块）。该技术的目标是（大致地）均衡每个块在洪流中的副本数量。

### CDN
当用户主机中的一个浏览器指令检索一个特定的视频（由URL标识）时，CDN必须截获该请求，以便能够：①确定此时适合用于该客户的CDN服务器集群；②将客户的请求重定向到该集群的某台服务器。




